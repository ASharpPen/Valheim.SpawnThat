using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using HarmonyLib;
using SpawnThat.Configuration;
using SpawnThat.Debugging;
using SpawnThat.Spawners.SpawnAreaSpawner.Configuration.BepInEx;
using SpawnThat.Utilities.Extensions;

namespace SpawnThat.Spawners.SpawnAreaSpawner.Debug;

internal static class SpawnAreaDataGatherer
{
    public static void ScanAndPrint()
    {
        if (ConfigurationManager.GeneralConfig is null ||
            !ConfigurationManager.GeneralConfig.WriteSpawnAreaSpawnersToFile.Value)
        {
            return;
        }

        if (ZoneSystem.instance.IsNotNull())
        {
            StringBuilder strBuilder = new();

            AddHeader(strBuilder);

            FindPrefabs(strBuilder);

            var serialized = strBuilder.ToString();

            DebugFileWriter.WriteFile(serialized, "spawnarea_spawners_pre_changes.txt", "SpawnArea spawners and where they exist");
        }
    }

    private static void AddHeader(StringBuilder str)
    {
        str.AppendLine($"# This file was auto-generated by Spawn That {SpawnThatPlugin.Version} at {DateTimeOffset.UtcNow.ToString("u")}, with Valheim '{Version.m_major}.{Version.m_minor}.{Version.m_patch}'.");
        str.AppendLine($"# The entries listed here were extracted at runtime, prior to being configured by Spawn That.");
        str.AppendLine($"# The file is intended for investigating existing spawners in the default Spawn That config format.");
        str.AppendLine($"# The \"Appears in\" is intended for helping show which \"IdentifyByX\" options can be used.");
        str.AppendLine($"");
    }

    private static void FindPrefabs(StringBuilder strBuilder)
    {
        var prefabs = ZNetScene.instance.m_prefabs.ToList();

        Dictionary<string, Data> spawnAreaSpawners = new();

        // Gather prefabs
        foreach (var prefab in prefabs)
        {
            var spawnArea = prefab.GetComponent<SpawnArea>();

            if (spawnArea.IsNull())
            {
                continue;
            }

            spawnAreaSpawners[spawnArea.GetCleanedName()] = new() { Spawner = spawnArea };
        }

        // Gather locations and biomes
        var orderedLocations = ZoneSystem.instance.m_locations
            .OrderBy(x => x.m_biome)
            .ThenBy(x => x.m_prefabName);

        foreach (var location in orderedLocations)
        {
            if (location.m_prefab.IsNull())
            {
                continue;
            }

            var spawners = location.m_prefab.GetComponentsInChildren<SpawnArea>();

            foreach (var spawner in spawners)
            {
                var key = spawner.GetCleanedName();

                if (spawnAreaSpawners.TryGetValue(key, out var data))
                {
                    data.Locations.Add(location.m_prefabName);

                    foreach (var biome in location.m_biome.Split())
                    {
                        data.Biomes.Add(biome);
                    }
                }
            }
        }

        // Gather dungeons
        HashSet<Room.Theme> activeThemes = new();

        Dictionary<Room.Theme, HashSet<string>> locationsByTheme = new();
        Dictionary<Room.Theme, HashSet<Heightmap.Biome>> biomesByTheme = new();

        foreach (var location in orderedLocations)
        {
            if (location.m_prefab.IsNull())
            {
                continue;
            }

            var dungeons = location.m_prefab.GetComponentsInChildren<DungeonGenerator>();

            foreach (var dungeon in dungeons)
            {
                foreach (var theme in dungeon.m_themes.Split())
                {
                    activeThemes.Add(theme);

                    if (locationsByTheme.TryGetValue(theme, out var locations))
                    {
                        locations.Add(location.m_prefabName);
                    }
                    else
                    {
                        locationsByTheme[theme] = new() { location.m_prefabName };
                    }

                    if (biomesByTheme.TryGetValue(theme, out var biomes))
                    {
                        foreach (var biome in location.m_biome.Split())
                        {
                            biomes.Add(biome);
                        }
                    }
                    else
                    {
                        biomesByTheme[theme] = location.m_biome.Split().ToHashSet();
                    }
                }
            }
        }

        // Find the rooms of each theme, and find their spawners
        foreach (var theme in activeThemes)
        {
            var rooms = DungeonDB
                .GetRooms()
                .Where(x => x.m_room.m_theme == theme)
                .ToList();

            foreach (var room in rooms)
            {
                var roomSpawners = room.m_room.GetComponentsInChildren<SpawnArea>();

                foreach (var spawner in roomSpawners)
                {
                    var key = spawner.GetCleanedName();

                    if (spawnAreaSpawners.TryGetValue(key, out var data))
                    {
                        data.Rooms.Add(room.m_room.name);

                        if (biomesByTheme.TryGetValue(theme, out var biomes))
                        {
                            foreach (var biome in biomes)
                            {
                                data.Biomes.Add(biome);
                            }
                        }

                        if (locationsByTheme.TryGetValue(theme, out var locations))
                        {
                            foreach (var location in locations)
                            {
                                data.Locations.Add(location);
                            }
                        }
                    }
                }
            }
        }

        // Serialize!
        
        foreach (var entry in spawnAreaSpawners.Values)
        {
            entry.Serialize(strBuilder);
            strBuilder.AppendLine();
        }
    }

    private class Data
    {
        public SpawnArea Spawner { get; set; }

        public HashSet<Heightmap.Biome> Biomes { get; set; } = new();

        public HashSet<string> Locations { get; set; } = new();

        public HashSet<string> Rooms { get; set; } = new();

        public void Serialize(StringBuilder str)
        {
            str.AppendLine($"# Appears in Biomes: {Biomes.Join()}");
            str.AppendLine($"# Appears in Locations: {Locations.Join()}");
            str.AppendLine($"# Appears in Rooms: {Rooms.Join()}");

            str.AppendLine($"[{Spawner.name}]");
            str.AppendLine($"{nameof(SpawnAreaSpawnerConfig.IdentifyByName)}={Spawner.GetCleanedName()}");
            str.AppendLine($"{nameof(SpawnAreaSpawnerConfig.LevelUpChance)}={Spawner.m_levelupChance.ToString(CultureInfo.InvariantCulture)}");
            str.AppendLine($"{nameof(SpawnAreaSpawnerConfig.SpawnInterval)}={Spawner.m_spawnIntervalSec.ToString(CultureInfo.InvariantCulture)}");
            str.AppendLine($"{nameof(SpawnAreaSpawnerConfig.SetPatrol)}={Spawner.m_setPatrolSpawnPoint}");
            str.AppendLine($"{nameof(SpawnAreaSpawnerConfig.ConditionPlayerWithinDistance)}={Spawner.m_triggerDistance.ToString(CultureInfo.InvariantCulture)}");
            str.AppendLine($"{nameof(SpawnAreaSpawnerConfig.ConditionMaxCloseCreatures)}={Spawner.m_maxNear.ToString(CultureInfo.InvariantCulture)}");
            str.AppendLine($"{nameof(SpawnAreaSpawnerConfig.ConditionMaxCreatures)}={Spawner.m_maxTotal.ToString(CultureInfo.InvariantCulture)}");
            str.AppendLine($"{nameof(SpawnAreaSpawnerConfig.DistanceConsideredClose)}={Spawner.m_nearRadius.ToString(CultureInfo.InvariantCulture)}");
            str.AppendLine($"{nameof(SpawnAreaSpawnerConfig.DistanceConsideredFar)}={Spawner.m_farRadius.ToString(CultureInfo.InvariantCulture)}");
            str.AppendLine($"{nameof(SpawnAreaSpawnerConfig.OnGroundOnly)}={Spawner.m_onGroundOnly}");

            for (int i = 0; i < Spawner.m_prefabs.Count; ++i)
            {
                var spawn = Spawner.m_prefabs[i];

                str.AppendLine();
                str.AppendLine($"[{Spawner.name}.{i}]");
                str.AppendLine($"{nameof(SpawnAreaSpawnConfig.Enabled)}={true}");
                str.AppendLine($"{nameof(SpawnAreaSpawnConfig.TemplateEnabled)}={true}");
                str.AppendLine($"{nameof(SpawnAreaSpawnConfig.PrefabName)}={spawn.m_prefab.GetCleanedName() ?? ""}");
                str.AppendLine($"{nameof(SpawnAreaSpawnConfig.SpawnWeight)}={spawn.m_weight.ToString(CultureInfo.InvariantCulture)}");
                str.AppendLine($"{nameof(SpawnAreaSpawnConfig.LevelMin)}={spawn.m_minLevel}");
                str.AppendLine($"{nameof(SpawnAreaSpawnConfig.LevelMax)}={spawn.m_maxLevel}");
            }
        }
    }
}
